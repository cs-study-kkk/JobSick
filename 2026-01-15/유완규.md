
────────────────
전체 개념 정리
프로세스 · 쓰레드 · 코루틴 · 동기 · 비동기
────────────────


1. 프로세스 (Process)

프로세스는 프로그램이 실행된 상태다.

롤은 프로그램이고
롤을 실행하면 프로세스가 된다.

작업 관리자를 보면
실행 중인 프로그램만 목록에 나오는데
이게 바로 프로세스다.

프로세스란
프로그램이 메모리에 올라가고
CPU를 할당받아 실행 중인 상태를 말한다.


프로세스의 핵심 특징

- 독립된 메모리 공간을 가진다
- 서로 직접 간섭할 수 없다
- 생성과 관리 비용이 크다
- 하나가 죽어도 다른 프로세스에는 영향이 없다


운영체제가 프로세스를 분리하는 이유

운영체제는 프로그램을 보호해야 한다.

롤이 오류로 죽었다고
크롬이나 유튜브까지 같이 멈추면 안 된다.

그래서
프로그램마다 메모리 공간을 나누고
서로 접근하지 못하게 한다.

이로 인해
안정성은 높아졌지만
메모리를 직접 공유하기는 어려워졌다.


프로세스 간 통신 (IPC)

메모리를 분리했기 때문에
프로세스끼리는 직접 데이터를 주고받을 수 없다.

그래서 IPC가 필요하다.

Pipe
- 한 프로세스의 출력을 다른 프로세스의 입력으로 연결
- 단방향, 부모-자식 관계에서 주로 사용

Socket
- 양방향 통신
- 네트워크 통신 가능
- 로컬 / 원격 프로세스 모두 가능

Shared Memory
- 공용 메모리 영역을 따로 만들고 연결
- 가장 빠르지만 관리가 어렵다


정리

프로세스는
안정성을 얻기 위해
비용과 통신 불편을 감수한 구조다.


────────────────
2. 쓰레드 (Thread)
────────────────

쓰레드는
프로세스 안에서 실제 일을 하는 작업자다.


쓰레드가 필요한 이유

웹 서버를 예로 들면

요청 A, B, C가 들어왔을 때
쓰레드가 하나면

A 처리 중 → B, C 대기

쓰레드가 여러 개면

A, B, C를 동시에 처리 가능


쓰레드의 핵심 설계 철학

공유할 건 공유하고
나눌 건 나누자


쓰레드의 특징

- 같은 프로세스의 메모리를 공유
- 생성 비용이 적다
- 통신이 쉽다
- 서로 간섭 가능
- 하나가 망가지면 전체가 위험해질 수 있다


쓰레드가 공유하는 것

- 코드 영역
- 전역 변수
- 힙 메모리
- 파일 핸들
- 소켓


쓰레드마다 따로 가지는 것

- 레지스터
- 프로그램 카운터(PC)
- 스택
- 실행 흐름


문제점

전역 변수는 공유 영역이다.

여러 쓰레드가 동시에 전역 변수를 수정하면
잘못된 값이 저장될 수 있다.

이게
경쟁 상태(Race Condition)다.


크롬 예시 (멀티 쓰레드)

- Main 쓰레드: 자바스크립트 실행
- Compositor: 화면 구성
- Raster: 렌더링
- IO: 네트워크 처리

유튜브 페이지에서 스크롤하면

- IO 쓰레드는 영상 데이터 수신
- Main 쓰레드는 JS 실행
- Compositor는 화면 갱신

이 작업들이 동시에 일어난다.


멀티 프로세스 vs 멀티 쓰레드 (크롬)

멀티 프로세스
- 탭 단위
- 한 탭이 죽어도 다른 탭은 안전

멀티 쓰레드
- 탭 내부 작업 분리
- 성능 향상 목적


정리

프로세스는 안정성
쓰레드는 성능을 담당한다.


────────────────
3. 코루틴 (Coroutine)
────────────────

프로세스와 쓰레드는
운영체제가 스케줄링한다.

코루틴은
프로그램이 직접 스케줄링한다.


왜 코루틴이 나왔는가

쓰레드는 가볍지만
여전히 OS 관리 비용이 있다.

또한
쓰레드는 I/O를 기다리는 동안
아무 일도 하지 않는다.


코루틴의 핵심 아이디어

기다리는 동안
다른 일을 하자


예시

하나의 쓰레드에서

- AI API 호출
- 응답 대기
- 단순 계산

순서대로 하면 비효율적이다.

API를 호출하고
응답을 기다리는 동안
다른 작업을 먼저 처리하고
응답이 오면 이어서 작업한다.

이게 코루틴이다.


코루틴의 특징

- 하나의 쓰레드에서 동작
- 번갈아 실행됨
- OS가 아닌 프로그램이 제어
- 매우 가볍다


라면 비유

10명이 10개의 라면을 끓이는 건 멀티 쓰레드다.

한 사람이
물을 올리고
불 켜고
옆 라면으로 이동했다가
물이 끓으면 돌아오는 건 코루틴이다.

CPU가 화구라면
코루틴은
기다리는 시간을 낭비하지 않는다.


코루틴의 한계

- CPU 연산을 병렬로 할 수 없다
- 한 코루틴이 오래 점유하면 전체가 멈춘다
- 강제로 중단할 수 없다
- 오류 추적이 어렵다


핵심 문장

코루틴은
계산을 빠르게 하는 기술이 아니라
기다리지 않게 만드는 기술이다.


────────────────
4. 동기 / 비동기
────────────────

동기

결과가 나올 때까지
현재 실행 흐름이 멈춘다.

res = a()
print(res)

a가 끝나기 전까지
다음 줄은 실행되지 않는다.


비동기

작업을 맡기고
나중에 결과를 받는다.

await a()

대기 중에는
다른 코루틴이 실행된다.

작업이 끝나면
중단된 지점부터 다시 실행된다.


중요한 차이

동기 / 비동기는
속도의 문제가 아니라
기다림을 처리하는 방식의 차이다.


────────────────
5. 언제 코루틴이 유리한가
────────────────

- 웹 서버
- API 서버
- 데이터베이스 요청
- 네트워크 통신

공통점

- I/O 대기가 많다
- CPU 연산은 적다

그래서
기다리는 시간을 숨길 수 있는
코루틴이 매우 유리하다.


────────────────
6. 최신 기술과의 연결
────────────────

nginx
- 이벤트 루프 기반
- 비동기 I/O
- 코루틴적 사고

redis
- 싱글 쓰레드
- 동기 처리
- 빠르고 예측 가능

kafka
- 비동기 메시지 처리
- 대량 I/O
- 흐름 중심 설계


최종 요약

프로세스는 안정성
쓰레드는 병렬성
코루틴은 대기 시간 활용

현대 서버 기술은
CPU를 더 쓰는 방향이 아니라
기다림을 숨기는 방향으로 발전해왔다.


────────────────
1. nginx
────────────────

nginx가 풀려고 한 핵심 문제는 이것이다.

웹 서버는
CPU 계산이 거의 없고
대부분의 시간이 네트워크 I/O 대기다.

요청을 받아서
백엔드 서버 응답 기다리고
클라이언트 전송을 기다린다.

전통적인 방식은
요청 하나당 쓰레드 하나였다.

문제는
쓰레드는 무겁고
컨텍스트 스위칭 비용이 크고
대부분의 쓰레드는 그냥 기다리기만 한다는 점이다.

nginx는 여기서 사고방식을 바꿨다.

“기다리는 동안 CPU를 잡고 있을 이유가 없다”

그래서 nginx는
멀티 프로세스 + 이벤트 루프 + 비동기 I/O 구조를 사용한다.

한 워커 프로세스 안에서
수천 개의 연결을 동시에 관리한다.

어떤 요청이 I/O 대기에 들어가면
그 요청은 실행 흐름에서 빠지고
다른 요청을 처리한다.

이건 개념적으로 보면
코루틴과 거의 동일한 사고 방식이다.

차이점은
nginx는 언어 레벨 코루틴이 아니라
OS 이벤트(epoll, kqueue)를 직접 사용해 구현했다는 점이다.

정리하면

nginx는
“쓰레드를 늘려서 병렬 처리”가 아니라
“대기 시간을 숨겨서 효율을 극대화”한 서버다.

그래서
프로세스 수는 적고
쓰레드도 거의 없고
I/O 대기가 많은 환경에서 압도적으로 강하다.


────────────────
2. redis
────────────────

redis는 구조가 매우 단순하다.

기본 철학은 이거다.

“아주 빠르게, 예측 가능하게”

이를 위해 redis는
기본적으로 싱글 프로세스
싱글 쓰레드로 동작한다.

이걸 처음 들으면 이렇게 생각한다.

“요즘 세상에 싱글 쓰레드?”

하지만 이유가 있다.

redis의 작업은
대부분 메모리 접근이다.
디스크 I/O나 네트워크 대기가 거의 없다.

즉
CPU-bound에 가까운 작업이다.

이 상황에서 쓰레드를 여러 개 쓰면
락이 필요해지고
경쟁 상태가 생기고
성능이 오히려 불안정해진다.

redis는 그래서 이렇게 선택했다.

- 한 번에 하나만 처리
- 대신 매우 빠르게 처리
- 모든 명령은 순차적

이 덕분에

동기 코드처럼 보이지만
성능은 매우 높고
데이터 일관성은 자동으로 보장된다.

오늘 배운 개념으로 말하면

redis는
“비동기 서버”가 아니라
“동기지만 빠른 서버”다.

그래서
웹 서버처럼 I/O 대기가 많은 곳에는 부적합하지만
캐시, 세션, 카운터처럼
짧고 확실한 작업에는 최적이다.


────────────────
3. kafka
────────────────

kafka가 풀려고 한 문제는 완전히 다르다.

“대량의 데이터를
끊기지 않고
확실하게 전달하고 싶다”

여기서 중요한 점은
즉시 처리보다
흐름과 안정성이다.

kafka는 기본적으로

- 비동기 메시징 시스템
- 생산자와 소비자를 분리한다

즉
보내는 쪽은

“나 이거 던질게”
하고 바로 다음 일을 한다.

받는 쪽은

“내가 준비됐을 때 가져갈게”
라고 한다.

이건 완벽한 비동기 모델이다.

동기 호출처럼
응답을 기다리지 않는다.

또한 kafka 내부는

- 디스크 I/O
- 네트워크 I/O
- 배치 처리

가 중심이다.

그래서 kafka는
멀티 쓰레드 + 비동기 I/O + 큐 구조를 사용한다.

오늘 배운 개념으로 말하면

kafka는
“기다림을 설계의 중심에 둔 시스템”이다.

기다림을 숨기고
흐름을 유지하는 것이 목표다.

그래서
웹 요청 처리에는 부적합하지만
로그 수집, 이벤트 스트림, 비동기 처리에는 압도적으로 강하다.


────────────────
전체 연결 요약
────────────────

nginx
- I/O 대기가 많다
- 코루틴적 사고
- 이벤트 루프 기반
- 기다리는 동안 다른 일 처리

redis
- CPU 작업 위주
- 동기 처리
- 단일 쓰레드
- 빠르고 예측 가능

kafka
- 대량 데이터 흐름
- 완전 비동기
- 생산자/소비자 분리
- 기다림 자체를 시스템으로 설계

결론 한 문장으로 정리하면 이거다.

현대 기술 스택은
“CPU를 더 쓰는 방법”이 아니라
“기다리는 시간을 어떻게 숨길 것인가”의 역사다.

