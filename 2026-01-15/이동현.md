# 브라우저 동작 원리

웹 브라우저 => 크롬이나 엣지, 사파리 등...

## 브라우저 핵심/주요 기능
=> client가 원하는 자료를  서버에 요청(request)하고 서버의 응답(response)를 받아 브라우저에 표시하는 것


※여기서 자료는 보통 HTML 문서를 의미하지만, 넓게는 PDF나 이미지까지 다양한 형태일 수 있음


일반적으로 서버는 하나의 자료만을 가지지 않고 여러 페이지를 제공


=> 각 자료/페이지의 주소를 URI(특정 리소스를 식별하는 통합 자원 식별자)로 구분하여 사용자로 하여금 가져갈 수 있도록 만들어 놓는다.

---

## 브라우저 구조

### 1. 유저 인터페이스(UI)
: 웹 페이지 자체를 제외한 브라우저 창에서 사용자가 상호작용할 수 있는 요소의 레이아웃을 정의한 것

### 2. 브라우저 엔진
: UI와 렌더링 엔진 간의 상호작용을 중간에서 관리하는 역할을 함


UI로부터 입력을 받아서 렌더링 엔진에 명령을 내릴 수 있도록 처리하는 부분


=> UI와 렌더링 엔진 사이에서 두 부분을 연결하는 중간자 역할

### 3. 렌더링 엔진
: 요청된 자료를 브라우저 창에 렌더링 하는 부분, 가장 비용이 많이 드는 작업 중 하나로 굉장히 중요한 요소 중 하나임


ex) HTML 페이지가 요청되면 HTML 과 CSS를 파싱하고 파싱 및 형식이 지정된 내용을 그대로 화면에 표시하는 역할을 담당함

### 4. networking(통신/네트워킹)
: HTTP 호출을 다루고 다른 네트워크 관련 작업을 처리함

### 5. 자바스크립트 해석기
: 웹 페이지에서 채워진 내용들을 동적으로 만들어주는 것이 자바 스크립트의 역할


=> 이러한 자바스크립트 코드를 파싱하고 실행하는데 사용되는 요소


각 브라우저마다 사용하는 JS 엔진의 유형이 다름

### 6. UI 백엔드
: 기본 OS의 UI 방식을 사용하고 있고, 주로 선택, 입력, 체크 box등과 같은 기본 위젯을 그리는데 사용

### 7. 자료 저장소
: 쿠키, 로컬 스토리지, 로컬 캐시등 다양한 유형의 데이터를 각 시스템에 맞게 로컬에 저장하는 역할
=> 브라우저는 WebSQL, IndexedDB 등과 같은 데이터 저장 메커니즘과 호환될 수 있어야 함

---

## critical rendering path
### 1. 문서 요청
: 주소창에 URL을 입력해 엔터 누르면 서버로부터 리소스를 응답받음


=> 브라우저에 어떤 사이트의 주소를 입력하면 그 주소에 해당하는 서버가 약속된 HTML 파일을 우리 브라우저로 전송

### 2. HTML 파싱 및 DOM 구축
: 받아온 문서를 파싱하는 과정이 이루어짐. 파싱은 렌더링 엔진에서 매우 중요한 과정이고, 파싱 결과는 보통 문서 구조를 나타내는 노드 트리임


이때 네트워크 상으로 전달되는 HTML 코드는 문자 형태일 수 없기 때문에 0과 1로 이루어진 8bit의 바이너리 데이터 형태 => 바이트 스트림이라고 함


이러한 바이트 스트림은 HTTP 응답의 body로 전송되고, 서버는 content-type 헤더를 통해 콘텐츠의 MIME 타입과 문자 인코딩 방식을 같이 명시하여 보내게 됨


※ 브라우저가 첫 번째 데이터의 청크를 바이트 형태로 받았으면, 수신 정보를 구문 분석(파싱)하기 시작 , 구문 분석은 브라우저가 네트워크를 통해 받은 데이터를 DOM이나 CSSOM으로 바꾸는 단계


=> 첫 번째 과정으로 바이트 코드를 지정된 문자 인코딩 방식에 따라 해석해 다시 텍스트로 변환하는 과정이 이루어짐


=> 그리고 일종의 1차 해석 과정인 토큰화가 이루어지는테, 여기서 입력 문자를 토큰 단위로 파싱하게 됨


※※ 토큰: 브라우저에 저장된 HTML의 시작과 종료 태그, 속성과 속성값 등 약속된 여러가지 값들을 의미


=> 토큰화는 토큰을 인지해 트리 생성자로 넘기고 다른 토큰을 확인하기 위해 다음 문자를 확인 -> 이 과정을 입력의 마지막까지 반복
=====================================================
ex)
<html>
   <body>
      Hello world
   </body>
</html>

초기 상태: 자료 상태
'<'를 만남 : 태그 열림 상태
A-Z까지의 문자를 만남 : 시작 태그 토큰을 생성, 태그 이름 상태 (>문자를 만날 떄 까지 유지)
> 문자에 도달: 바로 토큰이 발행, 상태는 다시 자료 상태
"/" 문자: 종료 태그 토큰을 생성하며 "태그 이름 상태"로 변경
=====================================================
이렇게 만들어진 토큰들을 의미 있는 단위(노드)로 만들어줌 => 각 노드는 객체 형태
만들어진 노드들은 그들의 관계를 반영한 하나의 DOM 트리를 만듦
이 과정을 진행하다가 파서가 이미지 태그나 링크 태그와 같은 논블로킹 자원을 발견하면, 브라우저는 해당 자원에 대한 다운로드 요청을 하고 이어서 파싱을 지속

CSS 파일을 만났을 때도 마찬가지로 파서는 지속적으로 동작하는데, async나 defer 같은 설정이 되어 있지 않은 <script> 태그를 만나게 되면 쓰레드는 자바스크립트 코드를 해석하는 데 돌입하기 때문에 파서를 중지


### 3. CSSOM 구축
렌더링을 위해 이루어지는 작업 중 하나는 CSS를 처리하고 CSSOM 트리를 만드는 일


CSS 파싱 과정은 HTML 파싱 과정과 거의 일치


=>  서버로부터 전달받은 CSS 파일을 바이트에서 문자로 변환하고, 토큰화 이후 노드를 만듦 


최종적으로 이러한 노드들이 모여 하나의 거대한 CSSOM이 만들어짐


=> 즉, 브라우저가 CSS 규칙을 이해할 수 있고 작업을 진행할 수 있도록 스타일 맵으로 변환하는 과정을 거치고, 


브라우저는 CSS에 있는 각각의 규칙을 읽고, 마찬가지로 트리 노드를 만듦

### 4. 렌더 트리 구축
: 이렇게 만들어진 DOM Tree와 CSSOM Tree를 합쳐서 렌더 트리(Render tree)라는 것을 생성 => (진짜 웹 사이트를 그리기 위한 최종 설계도)


렌더 트리에는 내용을 표시해야 할 순서와 문서의 시각적인 구성 요소를 포함하여 올바른 방식으로 내용들을 그려낼 수 있도록 하기 위한 목적이 있음


따라서 표시되는 각 요소의 레이아웃을 계산하는 데 사용되고 픽셀을 화면에 렌더링하는 paint 프로세스에 대한 입력을 위한 작업을 진행


#### 렌더 트리를 생성할 때 다음의 작업을 수행


1) DOM 트리의 루트에서 시작하여 표시되는 각 노드를 순회

- 일부 표시되지 않는 노드들은 생략
- 일부 노드는 css를 통해 숨길 수 있음 -> 이 경우에서도 렌더 트리에서 생략


2) 표시되는 각 노드에 대해 적절한 CSSOM 규칙을 찾아 적용


3) 콘텐츠 및 계산된 스타일과 함께 표시되는 노드를 내보냄

### 5. 레이아웃
: 렌더 트리에 맞게 요소를 배치하는 단계


글로벌 레이아웃과 로컬 레이아웃으로 나눔

- 글로벌: 처음 배치되거나 font와 같이 전역 스타일이 변경되는 경우, 창이 resize 되는 경우
- 로컬: 초기 배치 이후 일부 DOM 노드에 변경이 생기는 것처럼, 특정 부분만 재배치가 필요한 경우


처음 노드의 사이즈와 위치가 결정되는 것을 레이아웃이라 부르고, 이후에 노드의 크기와 위치를 다시 계산하는 것은 리플로우라고 부릅니다.

### 6. 페인트
: 각 노드를 화면에 페인팅하는 것


페인팅 단계에서 브라우저는 레이아웃 단계에서 계산된 각 박스를 실제 화면의 픽셀로 변환


페인팅에서 텍스트, 색깔, 경계, 그림자 및 버튼이나 이미지 같은 대체 요소를 포함하여 모든 요소의 시각적인 부분을 화면에 그리는 작업이 포함됨


paint 과정에서는 stacking contexts라는 스택에 명령을 쌓아 실행하게 됨. 스택은 LIFO(Last-In, First-out), 즉 후입선출 구조 이기 때문에 나중에 들어온 명령이 가장 먼저 실행되는 특징을 갖고 있음. stack에는 배경 색 - 배경 이미지 - 테두리 - 자식 - 아웃라인 순으로 명령이 쌓이고, 실행은 아웃라인 - 자식 - 테두리 - 배경 이미지 - 배경색 순서로 진행됨

### 7. 합성
앞서 paint 과정에서 사실은 한 페이지에 다 그리는 것이 아니라 여러 개의 레이어로 나누어 그리게 됩니다.


문서의 각 섹션이 각기 다른 레이어에서 그려질 때, 합성 과정에서는 이러한 섹션들을 모두 겹치는 과정을 수행하여 그들이 올바른 순서로 화면에 그려지는 것과 정확한 렌더링을 보장하는 역할을 함